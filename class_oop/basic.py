"""
-----------------------------------------------面向对象--------------------------------------------------------
代码(code)-->封装成函数(function)--->封装成类(class)--->模块(.py文件)--->包(package)
包和目录的区别：包是package, 目录是directory，包其实也是一个目录，但是多了一个__init__.py文件
包 = n个子包(每个包都有一个__init__.py) + n个模块(.py文件) + __init__.py文件

面向对象(OOP)-----万物皆对象，python是彻底的OOP，所有类型都是对象类型
比如, 1, 0.01, True, [1, 2, 3, 4], {'a':3, 'b':4}  都是对象
他们的类型 int float Bool list dict，都是对象类型

人：属性：(身高、体重、年龄)
    行为：(走路、吃饭、开车)

面向过程和面向对象：
都是一种解决问题的思路（思想）
面向过程，关注的是解决问题的每一个过程（步骤），亲历亲为，比如洗碗：第一步放水，第二步放洗洁精，第三步洗碗
面向对象，关注的是解决问题所需要的对象，比如洗碗：我可以让你洗碗，你又可以使用洗碗机
面向对象本身是对面向过程的封装

面向对象编程最重要的是：按照对象进行功能划分，找到对象，确定对象属性、行为

如何从面向过程过渡到面向对象？
确定每一个步骤之后，把这些步骤划分给不同的对象来处理，再确定每个对象的属性、行为

类：类名+属性+方法
属性和方法是抽象的概念，只有根据类创建的对象（实例），才有具体的属性值和方法实现

对象和类：
根据对象，抽象出类
根据类，实例化多个对象

比如，根据张三这个对象，抽象出不良青年这个类；  属性：身高、年龄；方法：吃、喝、嫖、赌
根据不良青年这个类，创建（实例化）不同的对象，比如张三、李四、王五，他们可以有不同的属性、行为
"""

# class MyStudent:
#     pass
#
# a = MyStudent()  # 创建（实例化）一个对象a
# b = MyStudent()  # 创建（实例化）一个对象b

print('-------------------------------------实例方法、 类方法、 静态方法-----------------------------------')


class Test:
    age = 10  # 类属性
    sex = 'male'
    name = 'student'

    def __init__(self):
        self.b = 5  # 实例属性
        print('这是构造方法，每次创建对象的时候都会调用')

    def eat(self):  # 第一个参数self不用管，实例调用的时候会自动把实例自己传递过来
        print('这是实例方法, self就是实例t', self)

    @classmethod
    def drink(cls):
        print('这是类方法', cls)

    @staticmethod
    def sing():                # 没有默认参数
        print('这是静态方法')


# 调用实例方法  # 只有实例可以调用
t = Test()
t.eat()

# 调用类方法  # 类、实例，都可以调用
Test.drink()
t.drink()

# 调用静态方法  # 类、实例，都可以调用
Test.sing()
t.sing()

# 调用属性
print(t.age, t.sex, t.name)  # 实例调用
print(Test.age, Test.sex, Test.name)  # 类调用

print('-----------------------------------面向对象四大特性---抽象---封装---继承---多态--------------------------')
print('-----------------------------------面向对象四大要素----类----对象---属性---方法--------------------------')

print('-------------------------------------抽象方法、 抽象类-----------------------------------')

-------------------