print('---------------------------------------------------值传递、引用传递------------------------------------------')

# 值传递
# 传递过来的，是一个数据的副本
# 修改副本，不会对原值产生影响

# 引用传递
# 传递过来的，是一个变量的地址
# 通过地址，可以操作同一份原件

# 在python中，没得选，是引用传递，确切的说，是对象的引用传递，或者叫赋值传递，但是：
# 如果数据类型是可变的，那么可以改变原件
# 如果数据类型是不可变，那么不可改变原件


# 例1：
def a(n):
    print(id(n))  # 两个地址是一样的，说明是引用传递
    print(n)


n = 10
print(id(n))
a(n)


# 例2：
def b(n):
    print(id(n))  # 两个地址是一样的，说明是引用传递
    n = 12
    print(id(n))  # 这里就不一样了，因为n是不可变的，所以只能开辟一块新的内存区域
    print('函数内部的局部变量应该为12', n)


n = 11
print(id(n))
b(n)
print('n最初是11，现在还应该是11', n)


# 例3：
def c(n):
    print(id(n))  # 两个地址是一样的，说明是引用传递
    n.append(4)
    print(id(n))  # 这里仍然一样，因为n是可变的，所以还是原来的地址，并没有开辟一个新区域
    print('n应该为[1,2,3,4]', n)


n = [1, 2, 3]
print(id(n))
c(n)
print('n最初为[1,2,3],现在应该为[1,2,3,4]', n)


# 例4：
# 在例2中，n最初为11，到最后还是11，那么怎样让他改变呢
def b(n):
    print(id(n))  # 两个地址是一样的，说明是引用传递
    n = 12
    print(id(n))  # 这里就不一样了，因为n是不可变的，所以只能开辟一块新的内存区域
    print('函数内部的局部变量应该为12', n)
    return n


n = 11
print(id(n))
n = b(n)
print('n最初是11，现在接收函数返回值，应该是12了', n)
print('n的新地址', id(n))


# 例5：
# 跟例3有区别
def c(n):
    print(id(n))  # 两个地址是一样的，说明是引用传递
    n = n + [4]
    print(id(n))  # 这里就不一样了，开辟了一个新区域为这个局部变量，但外面的还是不变
    print('局部变量n应该为[1,2,3,4]', n)


n = [1, 2, 3]
print(id(n))
c(n)
print('n最初为[1,2,3],现在还是[1,2,3]', n)  # 如果想要外面的也改变，那么只要函数return就可以了

print('---------------------------------------------------总结--------------------------------------')
# 如果想通过一个函数来修改某个变量的值，有两种方法：
# 一，直接将可变数据类型（列表、字典、集合）当作参数传入，直接在其上修改
# 二，第二则是创建一个新变量，保存修改后的值，然后return给原变量
# 第二种工作中更常用

print('-------------额外补充: l.append 和 l+=[4]操作之后，l的id不变，l = l+[4]之后，l的id改变了--------------------')

l = [1, 2, 3]
print(id(l))
l.append(4)
print(id(l))  # id没有变

l = [1, 2, 3]
print(id(l))
l = l + [4]
print(id(l))  # id变了

l = [1, 2, 3]
print(id(l))
l += [4]
print(id(l))  # id没有变
